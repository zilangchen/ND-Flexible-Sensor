# Cursor AI 执行规范 - 分步骤指南

## 🚨 强制执行要求
- **绝对遵守**：本文档中的每个步骤都是强制性的，不得跳过或违反
- **最高优先级**：当出现任何冲突时，本文档规范具有最高优先级
- **严格按序执行**：必须按照步骤顺序执行，不得颠倒或省略

---

## 📋 执行前检查清单 (每次必须执行)

### ✅ 步骤1: 读取开发记录
```
BEFORE ANY CODE MODIFICATION:
1. 读取 development_record.md 文件
2. 如果文件不存在，创建一个
3. 确认之前的修改记录和当前状态
4. 理解项目的历史背景
```

### ✅ 步骤2: 检查项目目标
```
BEFORE ANY CODE MODIFICATION:
1. 读取 objective.md 文件
2. 如果文件不存在，创建一个
3. 确认项目的核心目标和需求
4. 确保本次修改符合项目目标
```

### ✅ 步骤3: 制定修改计划
```
BEFORE IMPLEMENTATION:
1. 明确修改目的
2. 列出具体修改内容
3. 评估影响范围
4. 确认修改策略（直接修改原文件，不创建新文件）
```

---

## 🔧 代码修改执行流程

### ✅ 步骤4: 代码质量检查
```
BEFORE WRITING CODE:
1. 检查项目的linter/formatter配置
2. 确保遵循代码风格一致性：
   - Python: Black, Flake8, isort
   - JavaScript/TypeScript: ESLint, Prettier
3. 检查导入语句完整性
4. 确保无语法或类型错误
5. 强制要求：编写代码时必须预防性遵循linter规范
   - 代码行长度不超过79字符（Python PEP8）
   - 使用正确的缩进（4个空格，不使用Tab）
   - 函数和类定义前后保持正确的空行数
   - 导入语句按标准库、第三方库、本地模块顺序排列
   - 变量命名遵循snake_case规范
   - 避免未使用的导入和变量
   - 确保所有字符串使用一致的引号风格
```

### ✅ 步骤5: 安全修改策略
```
DURING MODIFICATION:
1. 直接在原文件中修改，不创建新文件
2. 大规模重构拆分为若干原子补丁
3. 每步都必须可编译/运行
4. 避免一次性大量修改
5. Linter错误修复特殊规则：
   - 允许一次性修复所有linter错误（格式化、缩进、导入等）
   - 使用自动化工具（black, isort, flake8 --fix）进行批量修复
   - Linter修复不受"避免一次性大量修改"限制
   - 修复后必须验证代码仍可正常运行
   - 优先使用预防性编码避免产生linter错误
```

### ✅ 步骤6: 错误处理与验证
```
DURING IMPLEMENTATION:
1. 添加必要的异常处理
2. 确保修改后代码可以正常运行
3. 验证功能是否按预期工作
4. 检查是否引入新的错误
5. 强制要求：所有程序实现必须包含完整的错误处理步骤
   - 为每个主要功能模块添加try-except块
   - 为可视化、文件操作、网络请求等易失败操作添加独立错误处理
   - 确保程序在遇到错误时能优雅降级而非崩溃
   - 记录详细的错误信息和恢复措施
   - 实现fail-safe机制，单点失败不影响整体功能
```

---

## 📝 文档记录要求

### ✅ 步骤7: 立即记录修改日志
```
IMMEDIATELY AFTER CODE MODIFICATION:
1. 在 development_record.md 中插入时间戳注释：
   # <Cursor-AI [当前实际日期和时间]>
   注意：必须使用当前系统的实际日期和时间，格式为 YYYY-MM-DD HH:MM:SS
   通过运行 date '+%Y-%m-%d %H:%M:%S' 命令获取当前时间，必须确保记录的时间准确无误，否则视为失败。
2. 记录修改目的
3. 记录修改内容摘要
4. 记录影响范围
5. 记录技术细节
6. 强制要求：更改内容后必须立即进行日志记录
   - 禁止在完成代码修改后延迟记录或遗忘记录
   - 每次代码修改完成后，必须立即插入新的时间戳记录
   - 记录必须包含修改前状态、修改内容、修改后状态的完整描述
   - 如果是多步骤修改，每个重要步骤完成后都要记录进展
   - 确保开发记录的时间线完整且准确
```

### ✅ 步骤8: 更新项目目标
```
AFTER COMPLETING USER REQUEST:
1. 检查此修改是否与项目相关
2. 如果修改与项目相关，检查 objective.md 是否需要更新
3. 如果用户提出新需求，及时更新目标文件
4. 确保文档与实际实现保持一致
```

---

## 🧹 文件管理与清理

### ✅ 步骤9: 标准文件夹管理与清理
```
AFTER DEBUGGING/TESTING:
1. 检查是否产生临时文件
2. 将调试文件移到 debug_history 文件夹
3. 如果 debug_history 不存在则创建
4. 清理不需要的临时文件
5. 强制要求：执行标准文件夹管理规则
   - 按文件类型和用途进行分类归档
   - 清理工作目录中的无用文件
   - 维护清晰的项目文件结构
   - 定期检查和整理文件夹内容

### 📁 标准文件夹分类规则：
- **result/**: 最终实验结果文件（CSV、图表、模型文件）
- **debug_history/**: 调试过程文件、临时脚本、测试输出
- **development_history/**: 开发过程记录、旧版本代码备份
- **logs/**: 程序运行日志、错误日志、性能监控日志；每个程序单独建子文件夹（如`logs/gpu_manager/`），其他通用日志按日期归类（如`logs/2025-07-22/`）
- **temp/**: 临时文件、缓存文件（定期清理）
- **backup/**: 重要文件备份（手动创建的备份）
- **scripts/**: 每个程序一个子文件夹，内含源代码、配置、程序专属指南等（示例：`scripts/gpu_manager/` 包含 `gpu_manager.py`、`gpu_manager_config.json`、`gpu_manager_guide.md`）
- **docs/**: 项目文档、说明文件、配置文件说明，以及使用指南、教程、手册（可按子文件夹分类，如 `docs/guide/`）


### 🔍 文件分类判断标准：
- **.log, .out, .err**: → logs/（按程序或日期子文件夹归档）
- **test_*, debug_*, temp_***: → debug_history/
- **backup_*, old_*, archive_***: → development_history/
- **result_*, final_*, summary_***: → result/
- **script_*, tool_*, util_***: → scripts/
- **scripts/*/*.md**: → 与对应程序放在一起（例如 `scripts/gpu_manager/gpu_manager_guide.md`）
- ***guide*.md, *tutorial*.md, *manual*.md**: → docs/guide/（使用指南类文档）
- **README*, *.md, *.txt**: → docs/（项目文档和说明）
- **缓存文件、临时文件**: → temp/（定期清理）

### 🗂️ 程序文件夹组织示例
```
 scripts/
 ├── gpu_manager/
 │   ├── gpu_manager.py
 │   ├── gpu_manager_config.json
 │   ├── gpu_manager_guide.md
 │   └── __init__.py
 └── data_processor/
     ├── processor.py
     ├── processor_config.yaml
     └── processor_guide.md
```

### 🧹 文件清理标准：
- **立即清理**：空文件、重复文件、临时缓存文件
- **归档处理**：调试输出、测试文件、旧版本代码
- **保留文件**：最终结果、重要日志、配置文件
- **定期检查**：temp文件夹（每次执行后）、debug_history（每周）

### ⚠️ 删除与归档规则补充
- 若文件不再需要，请 **先询问用户** 再删除。
- 有保存价值但不常用的文件，移动到 `development_history/<模块名>/` 归档。

### ✅ 步骤10: Git版本控制
```
AFTER COMPLETING MODIFICATIONS:
1. 检查工作树状态
2. 检测未提交的更改
3. 判断是否适合提交：
   - 有实际代码或文档修改
   - 修改已完成且经过验证
   - 修改具有明确的目的和价值
   - 不是临时性或实验性修改
4. 如果适合提交，询问用户是否提交
5. 如果用户确认，创建详细的提交信息：
   - 功能变更
   - 修复内容
   - 影响范围
6. 提交到GitHub
```

---

## 🚀 程序运行确认流程

### ✅ 步骤11: 运行前确认
```
BEFORE RUNNING FINAL PROGRAMS:
1. 询问用户是否使用screen开始运行
2. 提供预览或dry-run选项
3. 确认破坏性操作
4. 列出影响范围
```

### ✅ 步骤12: 运行监控
```
DURING PROGRAM EXECUTION:
1. 提供清晰的执行反馈
2. 监控程序运行状态
3. 记录关键进度信息
4. 及时报告异常情况
5. 报告程序运行时间时必须使用准确验证：
   - 使用 ps -o pid,etime,cmd 命令获取实际运行时间
   - 检查日志文件的开始时间戳进行核对
   - 禁止推测或使用不准确的时间信息
   - 所有时间报告必须基于实际命令输出
```

### ✅ 步骤12.1: 程序终止确认
```
BEFORE TERMINATING ANY RUNNING PROGRAM:
1. 必须先询问用户是否确认终止程序
2. 说明要终止的程序类型和可能的影响
3. 等待用户明确确认后才能执行终止操作
4. 记录终止原因和用户确认信息
5. 禁止在未经用户确认的情况下终止任何运行中的程序
```

---

## 🔍 特定项目规则

### ✅ 机器学习项目特殊要求
```
FOR ML PROJECTS:
1. 保持数据预处理的一致性
2. 记录模型参数和性能指标
3. 确保实验可重现性（设置随机种子）
4. 验证数据无泄露
5. 记录训练时间和资源使用
6. 时间信息准确性要求：
   - 报告实验运行时间前必须执行验证命令
   - 使用 ps -o etime 获取进程实际运行时间
   - 对比日志开始时间戳确认准确性
   - 禁止基于推测或计算提供时间信息
```

### ✅ 性能和安全考虑
```
ALWAYS CHECK:
1. 避免生成低效算法实现
2. 注意内存使用优化
3. 不硬编码敏感信息
4. 使用环境变量管理配置
5. 验证用户输入
```

---

## ⚠️ 失败处理协议

### ✅ 步骤13: 错误恢复
```
IF ANY STEP FAILS:
1. 立即停止执行
2. 撤销已完成的文件更改
3. 输出详细的失败原因
4. 提供建议的修复方案
5. 不继续执行后续步骤
```

### ✅ 步骤14: 冲突处理
```
IF CONFLICTS OCCUR:
1. 检查Git状态
2. 识别冲突原因
3. 提醒用户解决冲突
4. 建议创建新分支
5. 等待用户确认后继续
```

---

## 📊 执行检查表

每次执行时，必须确认以下检查项：

- [ ] ✅ 已读取 development_record.md
- [ ] ✅ 已检查 objective.md
- [ ] ✅ 已制定修改计划
- [ ] ✅ 已检查代码质量要求
- [ ] ✅ 使用安全修改策略
- [ ] ✅ 添加错误处理
- [ ] ✅ 确认程序包含完整错误处理步骤
- [ ] ✅ 立即记录修改日志
- [ ] ✅ 确认更改后立即进行了日志记录
- [ ] ✅ 更新项目目标（如需要）
- [ ] ✅ 管理临时文件
- [ ] ✅ 提交Git版本
- [ ] ✅ 运行前确认（如需要）
- [ ] ✅ 监控程序执行
- [ ] ✅ 验证时间信息准确性（如需要）
- [ ] ✅ 程序终止前确认（如需要）
- [ ] ✅ 处理错误和冲突

---

## 🎯 成功标准

一次成功的执行应该满足：

1. **完整性**：所有步骤都已执行
2. **可追溯性**：所有修改都有详细记录
3. **稳定性**：代码可以正常运行
4. **一致性**：符合项目规范和目标
5. **安全性**：没有引入安全风险
6. **可维护性**：代码质量良好，易于理解

---

## 📚 附录：常用命令模板

### 开发记录模板
```markdown
# <Cursor-AI [当前实际日期和时间]>
## 修改目的
[描述为什么要进行这次修改]

## 修改内容摘要
[列出具体修改了什么]

## 影响范围
[说明修改影响的文件和功能]

## 技术细节
[记录重要的技术实现细节]
```

**重要说明**：时间戳必须使用当前系统的实际日期和时间，格式为 YYYY-MM-DD HH:MM:SS。
在记录前应先运行 `date '+%Y-%m-%d %H:%M:%S'` 命令确认当前时间，确保记录的准确性。

### Git提交信息模板
```
类型: 简短描述

详细说明：
- 功能变更：[具体变更]
- 修复内容：[修复的问题]
- 影响范围：[影响的模块]
```

### 时间验证命令模板
```bash
# 获取进程实际运行时间
ps -o pid,etime,cmd -p [PID]

# 检查日志开始时间
head -5 [日志文件名] | grep -E "Starting|开始"

# 获取当前时间进行对比
date '+%Y-%m-%d %H:%M:%S'

# 示例验证流程
ps -o pid,etime,cmd -p 12345
head -5 experiment.log
date
```

---

**🔒 重要提醒：本文档是强制性执行规范，任何违反都可能导致项目问题。请严格按照步骤执行！** 